#!/usr/bin/env python

#necessary imports
from __future__ import print_function
import cv2
import numpy as np
#import time

#set B value
def set_B_value(value):
    blue_val = value
    cv2.setTrackbarPos('B', canvas_name, blue_val)

def set_G_value(value):
    green_val = value
    cv2.setTrackbarPos('G', canvas_name, green_val)

def set_R_value(value):
    red_val = value
    cv2.setTrackbarPos('R', canvas_name, red_val)


#instructions
print("Welcome to object painting!\n"
      "To exit, press 'q' while the video display window is selected.")

#hsv colorspace ranges (currently tennis ball)
H_range = (20, 60)
S_range = (40, 160)
V_range = (100, 240)

#window names
canvas_name = 'canvas'
cv2.namedWindow(canvas_name)

#create trackbars to set ink color
cv2.createTrackbar('B', canvas_name, 0, 255, set_B_value)
cv2.createTrackbar('G', canvas_name, 0, 255, set_G_value)
cv2.createTrackbar('R', canvas_name, 0, 255, set_R_value)

#initialize video capture
live_cap = cv2.VideoCapture(0)

#window height & width
img_Height = int(1.5*live_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))        #rows
img_Width = int(1.5*live_cap.get(cv2.CAP_PROP_FRAME_WIDTH))          #columns
#print(img_Height, img_Width)

#create blank canvas
canvas = 255*np.ones((img_Height, img_Width, 3), dtype = np.uint8)
canvas_in = np.copy(canvas)                 #create canvas to be "painted"
canvas_brush = np.copy(canvas)              #create canvas to show brush

#run as a loop
while True:
    #designate exit command - press q to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

    #read captured image for display
    ret, frame_in = live_cap.read()
    #flip image horizontally
    frame_in = cv2.flip(frame_in, 1)
    #upscale image
    new_dims = (img_Width, img_Height)
    frame_in = cv2.resize(frame_in, new_dims, cv2.INTER_AREA)

    #convert input from bgr to hsv
    frame_hsv = cv2.cvtColor(frame_in, cv2.COLOR_BGR2HSV)

    #color thresholding
    frame_threshold = cv2.inRange(frame_hsv, (H_range[0], S_range[0], V_range[0]),
                                  (H_range[1], S_range[1], V_range[1]))

    #gaussian blur
    frame_blur = cv2.GaussianBlur(frame_threshold, (7, 7), 0)
    #cv2.imshow('blurred', frame_blur)

    #erosion/dilation to remove noise
    frame_erosion = cv2.erode(frame_blur, np.ones((7, 7)), iterations=2)
    frame_dilation = cv2.dilate(frame_erosion, np.ones((5, 5)), iterations=2)

    #find contours
    _, contours, _ = cv2.findContours(frame_dilation, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    #print(contours)

    #identify biggest contour
    if len(contours) > 0:                                       #if contours exist
        biggest_contour = max(contours, key=cv2.contourArea)    #find biggest contour
    elif len(contours) == 0:                                    #if no contours
        cv2.imshow('brush spot', frame_in)          #MAKE SURE 'PAINTED' IMAGE SHOWN
                                                    #HERE IF NO CONTOURS
        continue

    #get ink color
    B_val = cv2.getTrackbarPos('B', canvas_name)
    G_val = cv2.getTrackbarPos('G', canvas_name)
    R_val = cv2.getTrackbarPos('R', canvas_name)

    #place brush spot on images at contour center
    if cv2.contourArea(biggest_contour) >= 1000:                    #if ball present
        #find smallest circle enclosing biggest contour
        (x, y), radius = cv2.minEnclosingCircle(biggest_contour)    #smallest enclosing circle
        centerX = int(x)            #brush center
        centerY = int(y)
        #radius = int(radius)        #brush radius
        img_brush = cv2.circle(frame_in, (centerX, centerY), 3, (0, 0, 255), 2)         #draw brush on captured image
        canvas_in = cv2.circle(canvas_in, (centerX, centerY), 2, (B_val, G_val, R_val), -1)        #paint on canvas
        canvas_brush = cv2.circle(canvas_brush, (centerX, centerY), 6, (0, 0, 255), 2)  #draw brush on canvas
        canvas_brush = cv2.circle(canvas_brush, (centerX, centerY), 2, (B_val, G_val, R_val), -1)     #paint on brush-canvas
    elif cv2.contourArea(biggest_contour) < 1000:       #if ball not present
        img_brush = frame_in                            #brush image is captured image
        canvas_brush = np.copy(canvas_in)               #canvas does not show brush

    cv2.imshow('brush spot', img_brush)             #show video with brush
    cv2.imshow(canvas_name, canvas_brush)              #show canvas with brush

    canvas_brush = np.copy(canvas_in)               #erase brush marker

#end video capture and close windows
live_cap.release()
cv2.destroyAllWindows()
