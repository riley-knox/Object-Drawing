#!/usr/bin/env python

#necessary imports
from __future__ import print_function
import numpy as np
import cv2
#import time

#set B value
def set_B_value(value):
    blue_val = value
    cv2.setTrackbarPos('B', canvas_name, blue_val)

def set_G_value(value):
    green_val = value
    cv2.setTrackbarPos('G', canvas_name, green_val)

def set_R_value(value):
    red_val = value
    cv2.setTrackbarPos('R', canvas_name, red_val)


#instructions
print("Welcome to object painting!\n"
      "\n\nTo exit, press 'q' while the video display window is selected."
      "\n\nThis program works best with a solid color background."
      "\n\nKeep your hand inside the blue bounding box in the bottom left corner."
      "\n\nYou can change ink color using the trackbars above the canvas.")

#hsv colorspace ranges
#tennis ball
H_range = (20, 60)
S_range = (40, 160)
V_range = (100, 240)
#skin
H_skin = (1, 20)
S_skin = (60, 170)
V_skin = (120, 255)

#canvas window name
canvas_name = 'canvas'
cv2.namedWindow(canvas_name)

#create trackbars to set ink color
cv2.createTrackbar('B', canvas_name, 0, 255, set_B_value)
cv2.createTrackbar('G', canvas_name, 0, 255, set_G_value)
cv2.createTrackbar('R', canvas_name, 0, 255, set_R_value)

#initialize video capture
live_cap = cv2.VideoCapture(0)

#window height & width
img_Height = int(1.5*live_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))        #rows
img_Width = int(1.5*live_cap.get(cv2.CAP_PROP_FRAME_WIDTH))          #columns
#print(img_Height, img_Width)

#create blank canvas
canvas = 255*np.ones((img_Height, img_Width, 3), dtype=np.uint8)
canvas_in = np.copy(canvas)                 #create canvas to be "painted"
canvas_brush = np.copy(canvas)              #create canvas to show brush

#run as a loop
while True:
    #designate exit command - press q to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

    #read captured image for display
    ret, frame_in = live_cap.read()
    #flip image horizontally
    frame_in = cv2.flip(frame_in, 1)
    #upscale image
    new_dims = (img_Width, img_Height)
    frame_in = cv2.resize(frame_in, new_dims, cv2.INTER_AREA)

    #bounding box for hand
    ROI_hand = np.copy(frame_in[int(img_Height/2):int(img_Height), 0:300, :])

    #place ROI rectangle on brush image
    img_brush = cv2.rectangle(frame_in, (0, img_Height), (300, img_Height/2), (255, 0, 0), 2)

    #convert input from bgr to hsv
    frame_hsv = cv2.cvtColor(frame_in, cv2.COLOR_BGR2HSV)
    ROI_hsv = cv2.cvtColor(ROI_hand, cv2.COLOR_BGR2HSV)

    #thresholding
    frame_threshold = cv2.inRange(frame_hsv, (H_range[0], S_range[0], V_range[0]),
                                  (H_range[1], S_range[1], V_range[1]))
    ROI_threshold = cv2.inRange(ROI_hsv, (H_skin[0], S_skin[0], V_skin[0]), (H_skin[1], S_skin[1], V_skin[1]))

    #gaussian blur
    frame_blur = cv2.GaussianBlur(frame_threshold, (7, 7), 0)
    ROI_blur = cv2.GaussianBlur(ROI_threshold, (7, 7), 0)

    #erosion/dilation to remove noise
    frame_erosion = cv2.erode(frame_blur, np.ones((7, 7)), iterations=2)
    frame_dilation = cv2.dilate(frame_erosion, np.ones((5, 5)), iterations=2)
    ROI_erosion = cv2.erode(ROI_blur, np.ones((7, 7)), iterations=2)
    ROI_dilation = cv2.dilate(ROI_erosion, np.ones((5, 5)), iterations=3)

    #find contours
    _, contours, _ = cv2.findContours(frame_dilation, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    _, ROI_contours, _ = cv2.findContours(ROI_dilation, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    #identify biggest contours
    #skin
    if len(ROI_contours) == 0:
        pass
    elif len(ROI_contours) > 0:
        ROI_big_cont = max(ROI_contours, key=cv2.contourArea)
        hull = cv2.convexHull(ROI_big_cont)
        #print(hull)
        cv2.drawContours(ROI_hand, [hull], -1, (51, 255, 255))
        cv2.imshow('convex hull', ROI_hand)

    #tennis ball
    if len(contours) > 0:                                       #if contours exist
        biggest_contour = max(contours, key=cv2.contourArea)    #find biggest contour
    elif len(contours) == 0:                                    #if no contours
        cv2.imshow('brush spot', img_brush)
        continue

    #get ink color
    B_val = cv2.getTrackbarPos('B', canvas_name)
    G_val = cv2.getTrackbarPos('G', canvas_name)
    R_val = cv2.getTrackbarPos('R', canvas_name)

    #place brush spot on images at contour center
    if cv2.contourArea(biggest_contour) >= 4000:                    #if ball present
        #find smallest circle enclosing biggest contour
        (x, y), radius = cv2.minEnclosingCircle(biggest_contour)    #smallest enclosing circle
        centerX = int(x)                #brush center
        centerY = int(y)
        #radius = int(radius)        #brush radius
        img_brush = cv2.circle(img_brush, (centerX, centerY),
                               3, (0, 0, 255), 2)                   #draw brush on captured image
        canvas_in = cv2.circle(canvas_in, (centerX, centerY),
                               2, (B_val, G_val, R_val), -1)        #paint on canvas
        canvas_brush = cv2.circle(canvas_brush, (centerX, centerY),
                                  6, (0, 0, 255), 2)                #draw brush on canvas
        canvas_brush = cv2.circle(canvas_brush, (centerX, centerY),
                                  2, (B_val, G_val, R_val), -1)     #paint on brush-canvas
    elif cv2.contourArea(biggest_contour) < 4000:                   #if ball not present
        img_brush = img_brush                                       #brush image is captured image
        canvas_brush = np.copy(canvas_in)                           #canvas does not show brush

    cv2.imshow('brush spot', img_brush)             #show video with brush
    cv2.imshow(canvas_name, canvas_brush)              #show canvas with brush

    canvas_brush = np.copy(canvas_in)               #erase brush marker

#end video capture and close windows
live_cap.release()
cv2.destroyAllWindows()
